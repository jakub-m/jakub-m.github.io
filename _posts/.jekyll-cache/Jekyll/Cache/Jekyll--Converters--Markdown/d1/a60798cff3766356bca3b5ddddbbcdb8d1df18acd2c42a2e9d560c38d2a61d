I"¸<p>After you read this post, you will learn how in <a href="https://www.airspace-intelligence.com/company">Airspace Intelligence</a> we used <a href="https://martinfowler.com/articles/patterns-of-distributed-systems/lamport-clock.html">Lamport
Clocks</a> to synchronize user settings between browsers and the backend service. You will also learn
how we employed <a href="https://dl.acm.org/doi/10.1145/3477132.3483540">Lightweight Formal Methods</a> to find bugs in our implementation of the synchronization
protocol.</p>

<p>In <a href="https://www.airspace-intelligence.com/company">Airspace Intelligence</a> we work on products supporting airlines‚Äô operations. One of the products we are
building is an application for messaging between the dispatchers coordinating the carriers‚Äô aircrafts and the pilots.</p>

<p>The application, later just called the App, integrates with the existing airline‚Äôs systems.  The App delivers slick
browser UI, and at the same time needs to support existing systems to notify that the user has a new message from the
pilot. This notification process happens in the backend, without involvement of the browser.  The backend relies on the
user settings to figure which user (dispatcher) should be notified about which message, because different dispatchers
are interested in different flights.</p>

<p>It is important that the browsers serving the App, connected to the backend, and the backend itself, have a consistent
view on the user settings,  so the backend can reliably trigger send notifications to the dispatchers about pending
messages. The case we especially want to avoid is that the browsers ‚Äúsee‚Äù different settings than the backed, or that
the settings don‚Äôt converge. At the same time, we want to provide snappy experience, when the dispatcher can select
different settings (different flight selectors), and the settings won‚Äôt flicker as the requests and responses got back
and forth between the browsers and the backend.</p>

<h1 id="why-the-trivial-solution-is-not-enough">Why the trivial solution is not enough?</h1>

<p>The diagram shows the browsers with the App connected to a single backend, and the backend connected to the existing
notification system.</p>

<p>DIAGRAM HERE</p>

<p>Different things can happen. A user can click settings in one browser, and then different settings in another one. There
can be transient network problems so the browsers fail to send the up-to-date settings to the backend. The user can
click back and forth the settings several time, or restart the browser.</p>

<p>The simplest thing to do would be sending the settings on each click.  This is simple, but has its problems. If you
clicked different settings fast, it could happen that you changed setting A and then B, but after you clicked B you got
a <em>response</em> for A that overwrote your browser settings with B unset. The experience wouldn‚Äôt be ‚Äúsnappy‚Äù.</p>

<p>Also, what if your request never reached the backend service?  Aha, you say, let‚Äôs add a periodic sync job in the
browser to synchronize state of the browser with the backend. This would also protect us from the case when someone
changes settings in other browser. This would work, but you need to figure which settings are the ‚Äúcurrent‚Äù ones, the
ones in the browser or the ones on the backend. Easy, just add a clock. But now how can you be <em>sure</em> that the clock is
right? It should, <a href="https://phys.org/news/2012-07-wreaks-internet-havoc.html">but what if not</a>? How can you reliably <a href="https://sookocheff.com/post/time/lamport-clock/">compare the clocks</a>?</p>

<p>You could add some integer that you increment every time you synchronize an event, and choose the larger one‚Ä¶ wait,
sounds like you are inventing the‚Ä¶</p>

<h1 id="lamport-clocks">Lamport Clocks.</h1>

<p>The idea is straightforward: make each process measure its own time as an integer. When an event, like a change in the settings,
happen, you increment the local counter of the process. When the processes exchange the information, they pass the
counter along, compare the received counter with the local counter, choose the larger one (local or received) together
with the accompanying state (i.e. the settings), <em>and increment the local clock by 1</em>. Mr. Lamport showed that
such clocks allow to reason about the <a href="https://en.wikipedia.org/wiki/Lamport_timestamp">ordering of the events</a>.</p>

<p>Each time the user clicks the settings, the Lamport clock (a local integer) in the browser increments by 1. The settings
are sent from the browsers to the backend, and the ‚Äúlarger clock wins‚Äù. Eventually, all the browsers and the backend
should converge to the same values‚Ä¶ at least that‚Äôs what we thought.</p>

<h1 id="lightweight-formal-methods">Lightweight formal methods</h1>

<p>Testing distributed system, even as simple as the above, is difficult. There are <a href="https://en.wikipedia.org/wiki/TLA%2B">dedicated frameworks and
languages, like TLA+</a> for that purpose. While expressive and battle-proven, a ‚Äútest‚Äù, or specification,
written in TLA+ would be doomed to become instantly unmaintained. Fortunately we stumbled upon
<a href="https://dl.acm.org/doi/10.1145/3477132.3483540">Lightweight Formal Methods</a>  paper, where the authors take a more lightweight approach.</p>

<p>TODO now about how it works for us
later about lightweight formal methods and the bug
example of the bug
example of the fix
why the bug was there  - no change of the state when the settings up to date</p>

<p>FUQ why not physical clocks?</p>
<h1 id="introduce-problem">introduce problem</h1>

<p>synchronize settings across browsers and backend
preserve ‚Äúsnappiness‚Äù of the application
an opened browser should not make the settings not synchronize
critical part, we don‚Äôt want the browsers and the backend workers to silently use stale settings</p>

<p>introduce lamport clocks</p>

<p>introduct lightweight formal models</p>

<p>problems</p>

<p>convergence
clock runaway
snappiness</p>

<p>approach</p>

<p>examples</p>

<h1 id="vim-spell-ft120">vim: spell ft=120</h1>

:ET