<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Running Docker images without Docker | Jakub Mikians blog</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Running Docker images without Docker" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I wrote this post trying to learn how Docker works under the hood. My learning goal was to run a Docker image without Docker." />
<meta property="og:description" content="I wrote this post trying to learn how Docker works under the hood. My learning goal was to run a Docker image without Docker." />
<link rel="canonical" href="https://jakub-m.github.io/2022/07/10/docker.html" />
<meta property="og:url" content="https://jakub-m.github.io/2022/07/10/docker.html" />
<meta property="og:site_name" content="Jakub Mikians blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-07-10T02:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Running Docker images without Docker" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-10T02:00:00+02:00","datePublished":"2022-07-10T02:00:00+02:00","description":"I wrote this post trying to learn how Docker works under the hood. My learning goal was to run a Docker image without Docker.","headline":"Running Docker images without Docker","mainEntityOfPage":{"@type":"WebPage","@id":"https://jakub-m.github.io/2022/07/10/docker.html"},"url":"https://jakub-m.github.io/2022/07/10/docker.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://jakub-m.github.io/feed.xml" title="Jakub Mikians blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Jakub Mikians blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Running Docker images without Docker</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-07-10T02:00:00+02:00" itemprop="datePublished">Jul 10, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I wrote this post trying to learn how <a href="https://en.wikipedia.org/wiki/Docker_(software)">Docker</a> works under the hood. My learning goal was to run a Docker image without Docker.</p>

<p>tl;dr: Surprisingly, Docker is not magic. Docker uses Linux cgroups, namespaces, overlayfs and other Linux mechanisms. Below I try to use those mechanisms by hand.</p>

<p>To reproduce the learning steps, clone <a href="https://github.com/jakub-m/no-docker">no-docker git repo</a> and follow the post and run the scripts.  I used Debian run from VirtualBox. Start with running <a href="https://github.com/jakub-m/no-docker/blob/main/00-prepare.sh">00-prepare.sh</a> to install all the dependencies and build a small <a href="https://github.com/jakub-m/no-docker/blob/main/tool.go"><code class="language-plaintext highlighter-rouge">tool</code> in Go</a> that we will use for experimenting.</p>

<p><a href="https://github.com/jakub-m/no-docker/blob/main/00-prepare.sh">00-prepare.sh</a></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash
set -eux
sudo apt-get install -y git golang jq curl psmisc
curl -O https://raw.githubusercontent.com/moby/moby/master/contrib/download-frozen-image-v2.sh
chmod a+x download-frozen-image-v2.sh
go build -o tool tool.go
</code></pre></div></div>

<h1 id="docker-image">Docker image</h1>

<p>Let’s download and un-archive <a href="https://hub.docker.com/_/busybox">busybox image</a> by running <a href="https://github.com/jakub-m/no-docker/blob/main/10-busybox-image.sh">10-busybox-image.sh</a>.  You can see that a Docker image is just a nested tar archive:</p>

<p><a href="https://github.com/jakub-m/no-docker/blob/main/10-busybox-image.sh">10-busybox-image.sh</a></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

set -eux
set -o pipefail

./download-frozen-image-v2.sh ./image-busybox/ busybox:latest
mkdir -p image-busybox-layer
find image-busybox -name layer.tar | xargs -n1 tar -C image-busybox-layer -xf
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ tree image-busybox
image-busybox
|-- a01835d83d8f65e3722493f08f053490451c39bf69ab477b50777b059579198f.json
|-- b906f5815465b0f9bf3760245ce063df516c5e8c99cdd9fdc4ee981a06842872
|   |-- json
|   |-- layer.tar
|   `-- VERSION
|-- manifest.json
`-- repositories
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">layer.tar</code> is a file tree with busybox tooling:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>image-busybox-layer/
|-- bin
(...)
|   |-- less
|   |-- link
|   |-- linux32
|   |-- linux64
|   |-- linuxrc
|   |-- ln
(...)
|-- etc
|   |-- group
(...)
</code></pre></div></div>

<h1 id="namespace-magic">namespace magic</h1>

<p><a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">Linux namespaces</a> create a separate “view” on Linux resources, such that one process can see the resources differently than other resources. The resources can be PIDs, file system mount points, network stack, and others.  You can see all the current namespaces with <code class="language-plaintext highlighter-rouge">lsns</code>. Let’s see how isolating and nesting PIDs look in practice with PID <a href="https://en.wikipedia.org/wiki/Linux_namespaces#Process_ID_(pid)">namespace</a>.</p>

<p><a href="https://man7.org/linux/man-pages/man1/unshare.1.html">unshare</a> system call and a command allows to set the separate namespace for a process. Run <a href="https://github.com/jakub-m/no-docker/blob/main/20-unshare.sh">20-unshare.sh</a> to fork a shell from busybox with a separate PID namespace, with a separate file system root.</p>

<p><a href="https://github.com/jakub-m/no-docker/blob/main/20-unshare.sh">20-unshare.sh</a></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

set -eux

cd image-busybox-layer
mkdir -p proc

sudo unshare --mount-proc \
    --fork \
    --pid \
    --cgroup \
    --root=$PWD \
    bin/sh
</code></pre></div></div>

<p>Have a look around. You will see that the root directory of the forked process is restricted (“jailed”) to the directory we specified when forking the shell. Now run the <code class="language-plaintext highlighter-rouge">tool</code> and see how the same process looks from the “inside” and “outside” of the forked shell. First copy the tool to XXX, then run the tool from the forked shell:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Run from the forked shell.  It does nothing but sleep.

./tool -hang hello &amp;
</code></pre></div></div>

<p>Restricting a directory tree of a process to a subdirectory is done with <a href="https://man7.org/linux/man-pages/man1/chroot.1.html">chroot</a>. You can check the actual root directory by checking /proc/*/root of processes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Run this from the parent (outside) shell

dev@debian:~/no-docker$ find  /proc/$(pidof tool) -name root -type l 2&gt;/dev/null | sudo xargs -n1 ls -l
lrwxrwxrwx 1 root root 0 Aug 27 22:03 /proc/1985/task/1985/root -&gt; /home/dev/no-docker/image-busybox-layer
(...)
</code></pre></div></div>

<p>You can also see how the PID namespaces work. The <code class="language-plaintext highlighter-rouge">tool</code> in the parent shell and in the forked shell have separate PID numbers. Also, the parent shell sees the processes run in the forked shell, but not vice-versa.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># from the forked shell
/ # ps aux | grep '[t]ool'
    7 root      0:00 ./tool -hang hello
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># from the parent shell
dev@debian:~$ ps aux | grep '[t]ool'
root       464  0.0  0.2 795136  2724 pts/1    Sl   10:16   0:00 ./tool -hang hello
</code></pre></div></div>

<h1 id="cgroups-limiting-resources">cgroups, limiting resources</h1>

<p>While namespaces isolate resources, <a href="https://docs.kernel.org/admin-guide/cgroup-v2.html">cgroups (control groups)</a> put limits on those resources. You can find the control group of our hanging tool with the following, run from the parent shell:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dev@debian:~$ cat /proc/$(pidof tool)/cgroup
0::/user.slice/user-1000.slice/session-92.scope
</code></pre></div></div>

<p>Let’s now use cgroups to see how we can cap memory of the forked shell.</p>

<p>First, run the tool with -mb option to make it allocate n MBs of memory:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># kill the previous tool if it still runs
killall -9 tool
./tool -mb 200
</code></pre></div></div>

<p>Find the file controlling the maximum memory of the tool process:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find /sys/fs/cgroup/ | grep $( cat /proc/$(pidof tool)/cgroup | cut -d/ -f 2-) | grep memory.max
/sys/fs/cgroup/user.slice/user-1000.slice/session-92.scope/memory.max
</code></pre></div></div>

<p>“/sys/fs/cgroup” is a mount point for cgroups file system:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mount | grep cgroup
cgroup2 on /sys/fs/cgroup type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate,memory_recursiveprot)
</code></pre></div></div>

<p><a href="https://facebookmicrosites.github.io/cgroup2/docs/memory-controller.html">“memory.max”</a> is a memory hard limit in the memory controller. Passing the hard limit causes OOM when memory usage cannot be reduced (more about it in a while).</p>

<p>Let’s put 100MB limit:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo sh -c 'echo 100m &gt; /sys/fs/cgroup/user.slice/user-1000.slice/session-92.scope/memory.max'
</code></pre></div></div>

<p>You will notice that the tool process… was not killed. How come? if you inspect <a href="https://facebookmicrosites.github.io/cgroup2/docs/memory-controller.html">memory.events</a> file, you will see that “max” entry increments.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat /sys/fs/cgroup/user.slice/user-1000.slice/session-92.scope/memory.events

low 0
high 0
max 3534 &lt;&lt; this changes when you run over the max limit
oom 0
oom_kill 0
</code></pre></div></div>

<p>The process was not killed because OS swapped the excessive memory. Check <code class="language-plaintext highlighter-rouge">cat /proc/swaps</code>, print it several times to see how it changes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dev@debian:~/no-docker$ while [ 1 ]; do cat /proc/swaps; sleep 2; done
Filename				Type		Size		Used		Priority
/dev/sda5                               partition	998396		2372		-2
Filename				Type		Size		Used		Priority
/dev/sda5                               partition	998396		2372		-2

# here I run the tool, you can see how the memory is swapped

Filename				Type		Size		Used		Priority
/dev/sda5                               partition	998396		103860		-2
Filename				Type		Size		Used		Priority
/dev/sda5                               partition	998396		121540		-2
Filename				Type		Size		Used		Priority
/dev/sda5                               partition	998396		116604		-2
</code></pre></div></div>

<p>If you turn the swapping off with <a href="https://linux.die.net/man/8/swapoff">swapoff</a>, the tool will be OOM-killed.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo swapoff -a
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2022/09/10 06:32:38 heap 0 mb, sys 218 mb
2022/09/10 06:32:39 allocate 200MB of memory
Killed
</code></pre></div></div>

<h1 id="overlayfs">overlayfs</h1>

<p>The last thing I looked at is the overlay file system, underlying volumes in Docker.  The <a href="https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html">overlay file system</a> allows logically merging of different mount points. You can overlay part of a parent file system with the forked file system.  You can check the overlayfs with the following:</p>

<p><a href="https://github.com/jakub-m/no-docker/blob/main/40-overlayfs.sh">40-overlayfs.sh</a></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

set -eux  

sudo mkdir -p /upper /lower /work /merged
sudo chmod 777 /upper /lower /work /merged
echo 'upper foo' &gt; /upper/foo
echo 'upper bar' &gt; /upper/bar
echo 'lower bar' &gt; /lower/bar
echo 'lower quux' &gt; /lower/quux
sudo mount -t overlay overlay -olowerdir=/lower,upperdir=/upper,workdir=/work /merged 
</code></pre></div></div>

<p>See how the /merged directory holds the content of both upper and lower directory, where “upper wins” if there are files with similar names:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dev@debian:~/no-docker$ tail -n+1 /merged/*
==&gt; /merged/bar &lt;==
upper bar

==&gt; /merged/foo &lt;==
upper foo

==&gt; /merged/quux &lt;==
lower quux
</code></pre></div></div>

<p>Worth noting that the workdir is a “technical” directory used by overlayfs to prepare files to move them in a single atomic operation.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Docker itself is not magic, the mechanisms of the kernel are the magic, and you can easily explore those mechanisms yourself. The one important part I didn’t cover here is the networking namespace.</p>


  </div><a class="u-url" href="/2022/07/10/docker.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Jakub Mikians blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Jakub Mikians blog</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jakub-m"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jakub-m</span></a></li><li><a href="https://www.twitter.com/JakubMikians"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">JakubMikians</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>An exercise in writing. All the opinions are mine, unless you share them.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
